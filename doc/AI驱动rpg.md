# 📜 提示词（总结版）

你是一个资深游戏架构师和引擎开发顾问。\
我正在开发一个 **AI 驱动的 2D RPG**，类似 **Skyrim / The Witcher**，但用
**LÖVE2D + Fennel（Lisp 方言）** 来实现。\
目标是让 **AI 能把故事转化为配置文件 + 脚本**，游戏引擎完全数据驱动。

请严格遵守以下思路：

------------------------------------------------------------------------

## 🎮 游戏设计原则

1.  **数据驱动**：
    -   游戏内容（地图、NPC、任务、物品、对话）全部写在配置文件（JSON/EDN/Fennel
        table）中。\
    -   游戏逻辑（战斗系统、任务状态机、对话树解析、NPC
        AI）写成通用引擎，不依赖具体任务。\
    -   配置文件 = 世界真相，AI 修改配置即可改变游戏。
2.  **脚本扩展（Fennel）**：
    -   使用 Fennel 作为嵌入式脚本语言，补充复杂逻辑：任务条件、NPC
        特殊行为、事件触发等。\
    -   Lisp 语法简单，AI 容易生成。
3.  **AI 的作用**：
    -   AI 输入：故事/设定（如"森林里的狼人袭击村庄"）。\
    -   AI 输出：
        -   地图配置（tmx/json）\
        -   NPC 定义（名字、属性、对话）\
        -   任务配置（步骤、条件、奖励）\
        -   对话树（可带分支与条件）\
        -   物品/敌人数据\
        -   （可选）简单的 Fennel 脚本逻辑
4.  **2D 优先**：
    -   先做 2D（等距/俯视/横版），实现基础玩法。\
    -   包含：地图加载、战斗系统、任务系统、NPC 交互、对话系统。\
    -   未来可扩展到 3D（类似 Skyrim）。

------------------------------------------------------------------------

## 🔧 技术架构

1.  **核心系统**（引擎通用逻辑，Lua/Fennel 实现）
    -   地图加载器（支持 Tiled .tmx/.json）\
    -   NPC 系统（状态机：闲逛、交互、战斗）\
    -   战斗系统（攻击、防御、技能，数据驱动）\
    -   任务系统（状态机：未接、进行、完成）\
    -   对话系统（树状结构 + 条件脚本）
2.  **配置文件示例**

-   世界：

    ``` json
    {
      "map": "forest.tmx",
      "npcs": ["witch", "bandit", "villager"],
      "quests": ["lost_sword", "witch_hunt"]
    }
    ```

-   任务：

    ``` json
    {
      "id": "lost_sword",
      "name": "The Lost Sword",
      "steps": [
        {"type": "dialog", "npc": "villager", "text": "Please find my sword."},
        {"type": "kill", "npc": "bandit"},
        {"type": "return", "npc": "villager", "reward": "gold:50"}
      ]
    }
    ```

-   物品：

    ``` json
    {"id": "iron_sword", "attack": 5, "durability": 100}
    ```

3.  **脚本扩展示例（Fennel）**

-   任务条件：

    ``` fennel
    (fn can-start-quest? [player world]
      (> (:level player) 5))
    ```

-   NPC 对话逻辑：

    ``` fennel
    (fn on-talk [npc player]
      (if (> (:reputation player) 10)
        "Thank you, hero!"
        "Go away, stranger."))
    ```

------------------------------------------------------------------------

## 🎯 最小可运行 Demo（MVP）

目标是先做一个能跑的雏形：\
1. 读入地图（tmx/json）。\
2. 玩家可以移动、与 NPC 对话。\
3. 支持一个简单任务（对话 -\> 打怪 -\> 回报）。\
4. 战斗系统只需要基础数值运算（HP、攻击、防御）。\
5. 所有数据（NPC、物品、任务）都从配置文件加载。

AI 只需生成配置文件，就能让游戏内容扩展。

------------------------------------------------------------------------

👉 今后的任务：\
逐步设计、实现和扩展这个 AI 驱动的 2D RPG 框架（Love2D +
Fennel），并提供代码示例、配置结构和 AI 生成方案。



做一个“通用引擎”确实是整个 AI 驱动 RPG 的基石。下面我分几个层次来回答你：

⸻

🏗️ 通用引擎的复杂度

其实它不像 Skyrim 引擎那样庞大，你不需要造一个 完整的 3D 游戏引擎。
目标是“通用玩法规则 + 数据驱动”，重点在 灵活 而不是 规模。

我把复杂度分成 3 个层次：

⸻

1️⃣ 最小可运行（MVP，几周能做）
	•	地图系统：读取 Tiled 地图（tmx/json），玩家能走动。
	•	NPC 系统：静态站立 + 对话框。
	•	任务系统：有限的几个模版（对话、杀怪、收集、返回）。
	•	战斗系统：简单数值（HP、攻击、防御）。
	•	配置文件：JSON + Fennel 脚本。

👉 开发量：
大约 2-4 周就能做出“提示词生成的小游戏”，AI 输出配置，LÖVE2D 读进去跑。

⸻

2️⃣ 通用 RPG 框架（几个月）
	•	扩展任务模版：护送、时间限制、解谜、分支剧情。
	•	NPC 行为：巡逻、跟随、攻击、对话条件。
	•	对话树系统：分支 + 条件判断。
	•	战斗扩展：技能、状态效果、装备系统。
	•	脚本接口：允许 Fennel 注入自定义逻辑。

👉 开发量：
2-6 个月，基本能跑出“2D 版 Skyrim”，玩家体验丰富。

⸻

3️⃣ 高度通用（1 年以上）
	•	AI 驱动世界生成：动态生成地图、生态系统、经济系统。
	•	复杂 AI：NPC 有日常作息、关系网、动态阵营。
	•	模块化引擎：玩家甚至可以换战斗系统、UI 系统。
	•	多人联机：共享世界，AI 生成动态事件。

👉 开发量：
接近一个小型游戏引擎团队的工作量（Unity/Unreal 的子集）。

⸻

🛠️ 如何开发（路线）
1.	确定核心循环（core loop）
•	移动 → 对话 → 接任务 → 战斗/探索 → 完成任务 → 奖励
•	保证这条循环数据驱动即可运行。
2.	设计数据模型（配置规范）
•	NPC、物品、任务、地图、对话，全部抽象成配置。
•	先用 JSON，复杂时用 Fennel 脚本扩展。
3.	实现引擎模块（模块化）
•	地图模块（加载、碰撞、显示）
•	任务模块（状态机 + 配置驱动）
•	NPC 模块（交互、AI、对话）
•	战斗模块（数值计算 + 配置驱动）
4.	接入 AI 生成
•	用自然语言描述 → AI 转换为配置文件 → 引擎加载运行。
•	一开始可以手写配置，确认引擎通用性足够，再让 AI 介入。
5.	迭代扩展
•	增加更多任务模版、NPC 行为、对话条件。
•	优化 AI → 配置的映射。

⸻

⚖️ 复杂度总结
	•	做一个最小可运行的通用引擎并不复杂，甚至比写一个完整 RPG 游戏还简单，因为你把玩法抽象成了模版。
	•	难点在于抽象：
	•	怎么设计任务模版足够灵活？
	•	怎么让配置能覆盖大多数剧情？
	•	怎么平衡“通用性”和“简单性”？

⸻

👉 换句话说，通用引擎 = 玩法模版库 + 配置驱动 + 脚本扩展。
先实现一个“通用的最小 RPG 框架”，再逐步加复杂度。

⸻
